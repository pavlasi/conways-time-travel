
#include <kissat/kissat.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "solve.h"

#define __unused __attribute__((unused))

//#define skip(cond) if((cond) <= 0) continue;
#define skip(cond) (void)0

#define kissat_add_n(solver, neigh, i, s)               \
    do {                                                \
        if(neigh[i] <= 0 || s) {                        \
            kissat_add(solver, abs(neigh[i]));          \
        }  else {                                       \
            if(!s) {                                    \
                kissat_add(solver, -abs(neigh[i]));     \
            }                                           \
        }                                               \
    } while(0)

/*
 * loneliness() -
 *
 * Adds clauses to ensure that a cell in the Game of Life is in a
 * "loneliness" state.  A cell is considered in a "lonely" state if:
 *
 *  1. It has no live neighbors.
 *  2. It has exactly one live neighbor.
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 * @neigh: An array containing the literals representing the states
 * (alive or dead) of the 8 neighbors of the cell.
 */
static void loneliness(kissat* solver, const int* neigh) {

    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);
        kissat_add_n(solver, neigh, k, 0);

        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            if(l != k) {
                kissat_add_n(solver, neigh, l, 1);
            }
        }
        kissat_add(solver, 0);
    }
}

/*
 *  overcrowding() -
 *
 *  @solver:
 *  @neigh:
 */
static void overcrowding(kissat* solver, const int* neigh, int curr) {

    size_t i;
    size_t j;
    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    for(i = 0; i < 8; i++) {
        skip(!neigh[i]);

        for(j = i + 1; j < 8; j++) {
            skip(!neigh[j]);

            for(k = j + 1; k < 8; k++) {
                skip(!neigh[k]);

                for(l = k + 1; l < 8; l++) {
                    skip(!neigh[l]);
                    kissat_add(solver, -abs(curr));
                    kissat_add_n(solver, neigh, i, 0);
                    kissat_add_n(solver, neigh, j, 0);
                    kissat_add_n(solver, neigh, k, 0);
                    kissat_add_n(solver, neigh, l, 0);
                    kissat_add(solver, 0);
                }
            }
        }
    }
}

/*
 * life() - 
 *
 * Adds clauses to the SAT solver to represent the "Life" rule of
 * Conway's Game of Life in reverse. This ensures that for a cell to
 * be alive at time t₁, it must have exactly 3 live neighbors at time
 * t₀, irrespective of its state at t₀.
 *
 * This function is used to deduce the possible states of the board at
 * time t₀ based on the known state of the board at time t₁.
 *
 * @solver: Pointer to the SAT solver instance where the clauses will
 * be added.
 *
 * @neigh: Array of 8 integers representing the variables
 * corresponding to the neighboring cells of the target cell.
 */
static void life(kissat* solver, const int* neigh, int curr) {

    size_t i;
    size_t j;
    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    for(i = 0; i < 8; i++) {
        skip(!neigh[i]);

        for(j = i + 1; j < 8; j++) {
            skip(!neigh[j]);

            for(k = j + 1; k < 8; k++) {
                skip(!neigh[k]);
                kissat_add(solver, abs(curr));
                kissat_add_n(solver, neigh, i, 0);
                kissat_add_n(solver, neigh, j, 0);
                kissat_add_n(solver, neigh, k, 0);

                for(l = 0; l < 8; l++) {
                    skip(!neigh[l]);
                    if(l != i && l != j && l != k) {
                        kissat_add_n(solver, neigh, l, 1);
                    }
                }
                kissat_add(solver, 0);
            }
        }
    }
}

/*
 * stagnation() -
 *
 * Adds clauses to ensure that a cell remains in a "stagnant" state,
 * meaning that if the cell is dead at time t0 , it remains dead at
 * time t1.
 *
 * The clauses added enforce that the current cell's state remains
 * unchanged based on the states of its neighboring cells.
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 *
 * @neigh: An array of integers representing the literals of the 8
 * neighbors surrounding the cell.
 * 
 * @curr: The literal representing the current state of the cell at
 * time t0. 
 */
static void stagnation(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;

    assert(solver);
    assert(neigh);

    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);

        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            kissat_add(solver, abs(curr));
            kissat_add_n(solver, neigh, k, 0);
            kissat_add_n(solver, neigh, l, 0);

            for(m = 0; m < 8; m++) {
                skip(!neigh[m]);
                if (m != k && m != l) {
                    kissat_add_n(solver, neigh, m, 1);
                }
            }
            kissat_add(solver, 0);
        }
    }
}

/*
 * preservation() -
 *
 * Adds clauses to ensure that a cell in the Game of Life
 * with the current state 'curr' is alive and has exactly 2 live
 * neighbors.
 *
 * @solver: The Kissat SAT solver that will be used to add the
 * clauses.
 *
 * @neigh: An array containing the literals representing the states of
 * the 8 neighbors.
 *
 * @curr: The literal representing the current cell (alive state).
 */
static void preservation(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;

    assert(solver);
    assert(neigh);

    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);

        for(l = k + 1; l < 8; l++) {
            skip(!neigh[l]);
            kissat_add(solver, -abs(curr));
            kissat_add_n(solver, neigh, k, 0);
            kissat_add_n(solver, neigh, l, 0);
            
            for(m = 0; m < 8; m++) {
                skip(!neigh[m]);
                if(m != l && m != k) {
                    kissat_add_n(solver, neigh, m, 1);
                }
            }
            kissat_add(solver, 0);
        }
    }
}

/*
 * neigh_init_i() -
 *
 * Initializes the `neigh` array with the coordinates of the 8
 * neighbors surrounding a given cell on the Game of Life board. The
 * function also calculates the number of live neighbors and stores it
 * in the `alive` parameter.
 *
 * @neigh: An array of integers where the literals (representing the
 * states of the 8 neighboring cells) will be stored.
 *
 * @b: The Game of Life board represented as a Board structure.
 *
 * @i: The row index of the cell for which neighbors are being
 * calculated.
 *
 * @j: The column index of the cell for which neighbors are being
 * calculated.
 *
 * @alive: A pointer to a size_t variable where the function will
 * store the number of live neighbors. A neighbor is considered live
 * if its literal is positive.
 */
static void neigh_init(int* neigh, const Board* b, size_t i, size_t j, size_t* alive) {

    int x;
    int y;
    int n;
    int m;
    size_t k;

    assert(b);
    assert(neigh);
    assert(alive);

    int pos[8][2] = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0 , -1}, {0 , 1},
        {1 , -1}, {1 , 0}, {1, 1}
    };

    *alive = 0;
    memset(neigh, 0, 8 * sizeof *neigh);

    n = (int)b->n;
    m = (int)b->m;
    for(k = 0; k < 8; k++) {

        x = (int)(i + pos[k][0]);
        y = (int)(j + pos[k][1]);

        if ((x >= 0 && x < n) && (y >= 0 && y < m)) {
            neigh[k] = b->table[x][y];
            if(neigh[k] > 0) {
                (*alive)++; 
            }
            neigh[k] = abs(neigh[k]);
        } else {
            neigh[k] = -(x * b->n + y + 500);
        }
    }
}

/*
 *  add_clauses() -
 *
 *  @solver:
 *  @b:
 */
static void add_clauses(kissat* solver, const Board* b) {

    size_t i;
    size_t j;
    size_t alive;

    int curr;
    int neigh[8];

    assert(solver);
    assert(b);

    for(i = 0; i < b->n; i++) {
        for(j = 0; j < b->m ; j++) {
            curr = b->table[i][j];
            neigh_init(neigh, b, i, j, &alive);
            if(curr > 0) {
                life(solver, neigh, curr);
                preservation(solver, neigh, curr);
            } else {
                //stagnation(solver, neigh, curr);
                //loneliness(solver, neigh);
                overcrowding(solver, neigh, curr);
            }
        }
    }
}

/*
 * fill_result_board() -
 *
 * This function fills the result board `r` with the values from the
 * solver.  It uses the state of the board `b` and the solver to
 * update `r` with the results of the SAT solver, where the values are
 * determined by the literal values in the solver (positive for alive
 * cells, negative for dead cells).
 *
 * @solver: A pointer to the Kissat SAT solver that has been used to
 * solve the problem and contains the literal values for each cell.
 *
 * @b: The input Game of Life board that contains the initial state of
 * the cells, represented by integers. The values represent the
 * literals for each cell (positive for alive, negative for dead).
 *
 * @r: The result board where the final state of the Game of Life will
 * be stored, with 1 for alive cells and -1 for dead cells.
 */
static __always_inline void fill_result_board(kissat* solver, const Board* b, Board* r) {

    size_t i;
    size_t j;

    assert(solver);
    assert(b);
    assert(r);

    r->n = b->n;
    r->m = b->m;
    for(i = 0; i < b->n; i++) {
        for(j = 0; j < b->m; j++) {
            r->table[i][j] = kissat_value(solver, abs(b->table[i][j]));
        }
    }
}

/*
 * solve() -
 *
 * This function solves the Game of Life problem for the given board
 * `b` and computes the immediate previous state (t0) of the board,
 * which is then stored in the result board `r`. The function uses the
 * Kissat SAT solver to reverse the Game of Life state from `t1` to
 * `t0` based on the current state in `b`.
 *
 * @b: The input Game of Life board representing the current state.
 * @r: The result board where the previous state (t0) of the Game of
 * Life will be stored. 
 *
 * return: 
 *  - '1' on success. 
 *  - '0' otherwise.
 */
int solve(const Board* b, Board* r) {

    kissat* solver;

    assert(b);
    assert(r);

    solver = kissat_init();
    if(solver) {
        add_clauses(solver, b);
        if(kissat_solve(solver) == 10) {
            fill_result_board(solver, b, r);
            return 1;
        }
    }

    kissat_release(solver);

    return 0;
}
