
#include <kissat/kissat.h>
#include <assert.h>
#include <stdlib.h>

#include "solve.h"

#define __unused __attribute__((unused))

static void loneliness(kissat* solver, const int* neigh) {

    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    /* loneliness */
    /* one neighboor is alive */
    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);
        kissat_add(solver, -neigh[k]);

        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            if(l != k) {
                kissat_add(solver, neigh[l]);
            }
        }
        kissat_add(solver, 0);
    }

    /* no neighboor is alive */
    for(l = 0; l < 8; l++) {
        skip(!neigh[l]);
        kissat_add(solver, neigh[l]);
    }
    kissat_add(solver, 0);
}

static void loneliness(kissat* solver, const int* neigh) {

    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    /* loneliness */
    /* one neighboor is alive */
    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);
        kissat_add(solver, -neigh[k]);

        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            if(l != k) {
                kissat_add(solver, neigh[l]);
            }
        }
        kissat_add(solver, 0);
    }

    /* no neighboor is alive */
    for(l = 0; l < 8; l++) {
        skip(!neigh[l]);
        kissat_add(solver, neigh[l]);
    }
    kissat_add(solver, 0);
}
/*
 * loneliness_i() -
 *
 * Adds clauses to ensure that a cell in the Game of Life is in a
 * "loneliness" state.  A cell is considered in a "lonely" state if:

 *  1. It has no live neighbors.
 *  2. It has exactly one live neighbor.
 *
 * This function is designed for internal cells so it does not handle
 * edge cases or cells near the boundaries. 
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 * @neigh: An array containing the literals representing the states
 * (alive or dead) of the 8 neighbors of the cell.
 */
static void __unused loneliness_i(kissat* solver, const int* neigh) {

    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    /* loneliness */
    /* one neighboor is alive */
    for(k = 0; k < 8; k++) {
        kissat_add(solver, neigh[k]);
        kissat_add(solver, 0); 

        for(l = 0; l < 8; l++) {
            if(l != k) {
                kissat_add(solver, -neigh[l]);
            }
        }
        kissat_add(solver, 0);
    }

    /* no neighboor is alive */
    for(l = 0; l < 8; l++) {
        kissat_add(solver, -neigh[l]);
    }
    kissat_add(solver, 0);
}

/*
 * stagnation_i() -
 *
 * Adds clauses to ensure that a cell remains in a "stagnant" state,
 * meaning that if the cell is dead at time t0 , it remains dead at
 * time t1. This function assumes the cell is internal (not on the
 * edge or corner) and does not account for boundary conditions.
 *
 * The clauses added enforce that the current cell's state remains
 * unchanged based on the states of its neighboring cells.
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 *
 * @neigh: An array of integers representing the literals of the 8
 * neighbors surrounding the cell.
 * 
 * @curr: The literal representing the current state of the cell at
 * time t0. 
 */
static void stagnation_i(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;

    assert(solver);
    assert(neigh);

    kissat_add(solver, curr);
    kissat_add(solver, 0);

    for(k = 0; k < 8; k++) {
        for(l = 0; l < 8; l++) {
            kissat_add(solver, neigh[k]);
            kissat_add(solver, neigh[l]);
            kissat_add(solver, 0);

            for(m = 0; m < 8; m++) {
                if (m != k && m != l) {
                    kissat_add(solver, -neigh[m]);
                }
            }
            kissat_add(solver, 0);
        }
    }
}

/*
 * preservation_i() -
 *
 * Adds clauses to ensure that an internal cell in the Game of Life
 * with the current state 'curr' is alive and has exactly 2 or 3 live
 * neighbors.
 *
 * @solver: The Kissat SAT solver that will be used to add the
 * clauses.
 *
 * @neigh: An array containing the literals representing the states of
 * the 8 neighbors.
 *
 * @curr: The literal representing the current cell (alive state).
 */
static void preservation_i(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;
    size_t n;

    assert(solver);
    assert(neigh);

    kissat_add(solver, curr);
    kissat_add(solver, 0);

    /* two or three neighboors alive */
    for(k = 0; k < 8; k++) {
        for(l = k + 1; l < 8; l++) {
            kissat_add(solver, neigh[k]);
            kissat_add(solver, neigh[l]);
            kissat_add(solver, 0);

            for(m = 0; m < 8; m++) {
                if (m != k && m != l) {
                    kissat_add(solver, -neigh[m]);
                }
            }
            kissat_add(solver, 0);

            for(m = l + 1; m < 8; m++) {
                kissat_add(solver, neigh[k]);
                kissat_add(solver, neigh[l]);
                kissat_add(solver, neigh[l]);
                kissat_add(solver, 0);

                for(n = 0; n < 8; n++) {
                    if (n != k && n != l && n != m) {
                        kissat_add(solver, -neigh[n]);
                    }
                }
                kissat_add(solver, 0);
            }
        }
    }
}

static void __unused neigh_init_b(int* neigh, const Board* b, size_t i, size_t j, size_t* alive) {

    assert(b);
    assert(neigh);
    assert(alive);

}

/*
 * neigh_init_i() -
 *
 * Initializes the `neigh` array with the coordinates of the 8
 * neighbors surrounding a given cell on the Game of Life board. The
 * function also calculates the number of live neighbors and stores it
 * in the `alive` parameter.
 *
 * This function is designed for internal cells, meaning the indices
 * `i` and `j` must not refer to border elements of the board. It does
 * not perform boundary checks, so it assumes that the provided cell
 * indices are valid for accessing all 8 neighbors.
 *
 * @neigh: An array of integers where the literals (representing the
 * states of the 8 neighboring cells) will be stored.
 *
 * @b: The Game of Life board represented as a Board structure.
 *
 * @i: The row index of the cell for which neighbors are being
 * calculated.
 *
 * @j: The column index of the cell for which neighbors are being
 * calculated.
 *
 * @alive: A pointer to a size_t variable where the function will
 * store the number of live neighbors. A neighbor is considered live
 * if its literal is positive.
 */
static void neigh_init_i(int* neigh, const Board* b, size_t i, size_t j, size_t* alive) {

    size_t k;
     
    assert(b);
    assert(neigh);
    assert(alive);

    int pos[8][2] = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0, -1} , {0, 1} ,
        {1, -1} , {1, 0} , {1, 1}
    };

    *alive = 0;
    for(k = 0; k < 8; k++) {
        neigh[k] = b->table[i + pos[k][0]][j + pos[k][1]];
        if(neigh[k] > 0) {
            (*alive)++; 
        }
        neigh[k] = abs(neigh[k]);
    }
}

/*
 *  add_clauses() -
 *
 *  @solver:
 *  @b:
 */
static void add_clauses(kissat* solver, const Board* b) {

    size_t i;
    size_t j;
    size_t alive;
    int neigh[8];

    assert(solver);
    assert(b);

    /*
     *  Internal elements
     */
    for(i = 1; i < b->n - 1; i++) {
        for(j = 1; j < b->m - 1; j++) {
            neigh_init_i(neigh, b, i, j, &alive);
            if(b->table[i][j] > 0) {
                preservation_i(solver, neigh, b->table[i][j]);
            } else {
                stagnation_i(solver, neigh, b->table[i][j]);
            }
        }
    }

    /*
     *  Border elements
     *
    for(i = 0; i < b->n; i += b->n - 1) {
        for(j = 1; j < N - 1; j++) {
             
        }
    }
*/
}

/*
 * fill_result_board() -
 *
 * This function fills the result board `r` with the values from the
 * solver.  It uses the state of the board `b` and the solver to
 * update `r` with the results of the SAT solver, where the values are
 * determined by the literal values in the solver (positive for alive
 * cells, negative for dead cells).
 *
 * @solver: A pointer to the Kissat SAT solver that has been used to
 * solve the problem and contains the literal values for each cell.
 *
 * @b: The input Game of Life board that contains the initial state of
 * the cells, represented by integers. The values represent the
 * literals for each cell (positive for alive, negative for dead).
 *
 * @r: The result board where the final state of the Game of Life will
 * be stored, with 1 for alive cells and -1 for dead cells.
 */
static __always_inline void fill_result_board(kissat* solver, const Board* b, Board* r) {

    size_t i;
    size_t j;

    assert(solver);
    assert(b);
    assert(r);

    for(i = 0; i < b->n; i++) {
        for(j = 0; j < b->m; j++) {
            r->table[i][j] = kissat_value(solver, abs(b->table[i][j]));
        }
    }
}

/*
 * solve() -
 *
 * This function solves the Game of Life problem for the given board
 * `b` and computes the immediate previous state (t0) of the board,
 * which is then stored in the result board `r`. The function uses the
 * Kissat SAT solver to reverse the Game of Life state from `t1` to
 * `t0` based on the current state in `b`.
 *
 * @b: The input Game of Life board representing the current state.
 * @r: The result board where the previous state (t0) of the Game of
 * Life will be stored. 
 *
 * return: 
 *  - '1' on success. 
 *  - '0' otherwise.
 */
int solve(const Board* b, Board* r) {

    int ret;
    kissat* solver;

    assert(b);
    assert(r);

    solver = kissat_init();
    if(solver) {
        add_clauses(solver, b);
        if(kissat_solve(solver) == 10) {
            fill_result_board(solver, b, r);
            return 1;
        }
    }

    kissat_release(solver);

    return 0;
}
