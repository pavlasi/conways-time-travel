
#include <kissat/kissat.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "solve.h"

#define __unused __attribute__((unused))

#define skip(cond) if(cond) continue;

/*
 * loneliness() -
 *
 * Adds clauses to ensure that a cell in the Game of Life is in a
 * "loneliness" state.  A cell is considered in a "lonely" state if:

 *  1. It has no live neighbors.
 *  2. It has exactly one live neighbor.
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 * @neigh: An array containing the literals representing the states
 * (alive or dead) of the 8 neighbors of the cell.
 */
/*
static void loneliness(kissat* solver, const int* neigh, size_t alive) {

    size_t k;
    size_t l;

    assert(solver);
    assert(neigh);

    if(alive == 1) {
        for(k = 0; k < 8; k++) {
            skip(!neigh[k]);
            kissat_add(solver, -neigh[k]);

            for(l = 0; l < 8; l++) {
                skip(!neigh[l]);
                if(l != k) {
                    kissat_add(solver, neigh[l]);
                }
            }
            kissat_add(solver, 0);
        }
    }

    if(!alive) {
        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            kissat_add(solver, -neigh[l]);
        }
        kissat_add(solver, 0);
    }
}
*/
static void __unused loneliness(kissat* solver, const int* neigh, size_t alive) {
    for (size_t a = 0; a < 8; a++) {
        skip(!neigh[a]);
        for (size_t b = a + 1; b < 8; b++) {
            skip(!neigh[b]);
            for (size_t c = b + 1; c < 8; c++) {
                skip(!neigh[c]);
                for (size_t d = c + 1; d < 8; d++) {
                    skip(!neigh[d]);
                    for (size_t e = d + 1; e < 8; e++) {
                        skip(!neigh[e]);
                        for (size_t f = e + 1; f < 8; f++) {
                            skip(!neigh[f]);
                            for (size_t g = f + 1; g < 8; g++) {
                                skip(!neigh[g]);
                                kissat_add(solver, -neigh[a]);
                                    kissat_add(solver, -neigh[b]);
                                kissat_add(solver, -neigh[c]);
                                kissat_add(solver, -neigh[d]);
                                kissat_add(solver, -neigh[e]);
                                kissat_add(solver, -neigh[f]);
                                kissat_add(solver, -neigh[g]);
                                kissat_add(solver, 0);
                            }
                        }
                    }
                }
            }
        }
    }
}

static void __unused overcrowding(kissat* solver, const int* neigh) {

    for(size_t i = 0; i < 8; i++) {
        skip(!neigh[i]);
        for(size_t j = i + 1; j < 8; j++) {
            skip(!neigh[j]);
            for(size_t k = j + 1; k < 8; k++) {
                skip(!neigh[k]);
                for(size_t l = k + 1; l < 8; l++) {
                    skip(!neigh[l]);
                    kissat_add(solver, neigh[i]);
                    kissat_add(solver, neigh[j]);
                    kissat_add(solver, neigh[k]);
                    kissat_add(solver, neigh[l]);
                    kissat_add(solver, 0);
                }
            }
        }
    }
}

static void __unused life(kissat* solver, const int* neigh, int curr) {

    size_t i;
    size_t j;
    size_t k;
    size_t l;

    for(i = 0; i < 8; i++) {
        skip(!neigh[i]);

        for(j = i + 1; j < 8; j++) {
            skip(!neigh[j]);

            for(k = j + 1; k < 8; k++) {
                skip(!neigh[k]);
                kissat_add(solver, -neigh[i]);
                kissat_add(solver, -neigh[j]);
                kissat_add(solver, -neigh[k]);

                for(l = 0; l < 8; l++) {
                    skip(!neigh[l]);
                    if(l != i && l != j && l != k) {
                        kissat_add(solver, neigh[l]);
                    }
                }
                kissat_add(solver, 0);
            }
        }
    }
}

/*
 * stagnation() -
 *
 * Adds clauses to ensure that a cell remains in a "stagnant" state,
 * meaning that if the cell is dead at time t0 , it remains dead at
 * time t1.
 *
 * The clauses added enforce that the current cell's state remains
 * unchanged based on the states of its neighboring cells.
 *
 * @solver: The Kissat SAT solver that will be used to add the clauses.
 *
 * @neigh: An array of integers representing the literals of the 8
 * neighbors surrounding the cell.
 * 
 * @curr: The literal representing the current state of the cell at
 * time t0. 
 */
static void stagnation(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;

    assert(solver);
    assert(neigh);

    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);

        for(l = 0; l < 8; l++) {
            skip(!neigh[l]);
            kissat_add(solver, abs(curr));
            kissat_add(solver, -neigh[k]);
            kissat_add(solver, -neigh[l]);

            for(m = 0; m < 8; m++) {
                skip(!neigh[m]);
                if (m != k && m != l) {
                    kissat_add(solver, neigh[m]);
                }
            }
            kissat_add(solver, 0);
        }
    }
}

/*
 * preservation() -
 *
 * Adds clauses to ensure that a cell in the Game of Life
 * with the current state 'curr' is alive and has exactly 2 live
 * neighbors.
 *
 * @solver: The Kissat SAT solver that will be used to add the
 * clauses.
 *
 * @neigh: An array containing the literals representing the states of
 * the 8 neighbors.
 *
 * @curr: The literal representing the current cell (alive state).
 */
static void preservation(kissat* solver, const int* neigh, int curr) {

    size_t k;
    size_t l;
    size_t m;

    assert(solver);
    assert(neigh);

    for(k = 0; k < 8; k++) {
        skip(!neigh[k]);

        for(l = k + 1; l < 8; l++) {
            skip(!neigh[l]);
            kissat_add(solver, -abs(curr));
            kissat_add(solver, -neigh[k]);
            kissat_add(solver, -neigh[l]);
            
            for(m = 0; m < 8; m++) {
                skip(!neigh[m]);
                if(m != l && m != k) {
                    kissat_add(solver, neigh[m]);
                }
            }
            kissat_add(solver, 0);
        }
    }
}

/*
 * neigh_init_i() -
 *
 * Initializes the `neigh` array with the coordinates of the 8
 * neighbors surrounding a given cell on the Game of Life board. The
 * function also calculates the number of live neighbors and stores it
 * in the `alive` parameter.
 *
 * @neigh: An array of integers where the literals (representing the
 * states of the 8 neighboring cells) will be stored.
 *
 * @b: The Game of Life board represented as a Board structure.
 *
 * @i: The row index of the cell for which neighbors are being
 * calculated.
 *
 * @j: The column index of the cell for which neighbors are being
 * calculated.
 *
 * @alive: A pointer to a size_t variable where the function will
 * store the number of live neighbors. A neighbor is considered live
 * if its literal is positive.
 */
static void neigh_init(int* neigh, const Board* b, size_t i, size_t j, size_t* alive) {

    size_t k;
    size_t x;
    size_t y;
     
    assert(b);
    assert(neigh);
    assert(alive);

    int pos[8][2] = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0 , -1}, {0 , 1},
        {1 , -1}, {1 , 0}, {1, 1}
    };

    memset(neigh, 0, 8 * sizeof *neigh);

    *alive = 0;
    for(k = 0; k < 8; k++) {

        x = i + pos[k][0];
        y = j + pos[k][1];

        if (x < b->n && y < b->m) {
            neigh[k] = b->table[x][y];
            if(neigh[k] > 0) {
                (*alive)++; 
            }
            neigh[k] = abs(neigh[k]);
        }
    }
}

/*
 *  add_clauses() -
 *
 *  @solver:
 *  @b:
 */
static void add_clauses(kissat* solver, const Board* b) {

    size_t i;
    size_t j;
    size_t alive;
    int neigh[8];

    assert(solver);
    assert(b);

    for(i = 0; i < b->n; i++) {
        for(j = 0; j < b->m ; j++) {
            neigh_init(neigh, b, i, j, &alive);
            if(b->table[i][j] > 0) {
                preservation(solver, neigh, b->table[i][j]);
            } else {
                stagnation(solver, neigh, b->table[i][j]);
                loneliness(solver, neigh, alive);
            }
        }
    }
}

/*
 * fill_result_board() -
 *
 * This function fills the result board `r` with the values from the
 * solver.  It uses the state of the board `b` and the solver to
 * update `r` with the results of the SAT solver, where the values are
 * determined by the literal values in the solver (positive for alive
 * cells, negative for dead cells).
 *
 * @solver: A pointer to the Kissat SAT solver that has been used to
 * solve the problem and contains the literal values for each cell.
 *
 * @b: The input Game of Life board that contains the initial state of
 * the cells, represented by integers. The values represent the
 * literals for each cell (positive for alive, negative for dead).
 *
 * @r: The result board where the final state of the Game of Life will
 * be stored, with 1 for alive cells and -1 for dead cells.
 */
static __always_inline void fill_result_board(kissat* solver, const Board* b, Board* r) {

    size_t i;
    size_t j;

    assert(solver);
    assert(b);
    assert(r);

    r->n = b->n;
    r->m = b->m;
    for(i = 0; i < b->n; i++) {
        for(j = 0; j < b->m; j++) {
            r->table[i][j] = kissat_value(solver, abs(b->table[i][j]));
        }
    }
}

/*
 * solve() -
 *
 * This function solves the Game of Life problem for the given board
 * `b` and computes the immediate previous state (t0) of the board,
 * which is then stored in the result board `r`. The function uses the
 * Kissat SAT solver to reverse the Game of Life state from `t1` to
 * `t0` based on the current state in `b`.
 *
 * @b: The input Game of Life board representing the current state.
 * @r: The result board where the previous state (t0) of the Game of
 * Life will be stored. 
 *
 * return: 
 *  - '1' on success. 
 *  - '0' otherwise.
 */
int solve(const Board* b, Board* r) {

    kissat* solver;

    assert(b);
    assert(r);

    solver = kissat_init();
    if(solver) {
        add_clauses(solver, b);
        if(kissat_solve(solver) == 10) {
            fill_result_board(solver, b, r);
            return 1;
        }
    }

    kissat_release(solver);

    return 0;
}
